import*as e from"react";import t from"prop-types";import{unstable_useForkRef as n,unstable_ownerDocument as r,elementAcceptingRef as o,exactProp as c}from"@mui/utils";import{jsx as u,jsxs as s}from"react/jsx-runtime";"use client";const a=["input","select","textarea","a[href]","button","[tabindex]","audio[controls]","video[controls]",'[contenteditable]:not([contenteditable="false"])'].join(",");function getTabIndex(e){const t=parseInt(e.getAttribute("tabindex")||"",10);return Number.isNaN(t)?e.contentEditable==="true"||(e.nodeName==="AUDIO"||e.nodeName==="VIDEO"||e.nodeName==="DETAILS")&&e.getAttribute("tabindex")===null?0:e.tabIndex:t}function isNonTabbableRadio(e){if(e.tagName!=="INPUT"||e.type!=="radio")return false;if(!e.name)return false;const getRadio=t=>e.ownerDocument.querySelector(`input[type="radio"]${t}`);let t=getRadio(`[name="${e.name}"]:checked`);t||(t=getRadio(`[name="${e.name}"]`));return t!==e}function isNodeMatchingSelectorFocusable(e){return!(e.disabled||e.tagName==="INPUT"&&e.type==="hidden"||isNonTabbableRadio(e))}function defaultGetTabbable(e){const t=[];const n=[];Array.from(e.querySelectorAll(a)).forEach(((e,r)=>{const o=getTabIndex(e);o!==-1&&isNodeMatchingSelectorFocusable(e)&&(o===0?t.push(e):n.push({documentOrder:r,tabIndex:o,node:e}))}));return n.sort(((e,t)=>e.tabIndex===t.tabIndex?e.documentOrder-t.documentOrder:e.tabIndex-t.tabIndex)).map((e=>e.node)).concat(t)}function defaultIsEnabled(){return true}function FocusTrap(t){const{children:o,disableAutoFocus:c=false,disableEnforceFocus:a=false,disableRestoreFocus:i=false,getTabbable:l=defaultGetTabbable,isEnabled:d=defaultIsEnabled,open:f}=t;const b=e.useRef(false);const p=e.useRef(null);const m=e.useRef(null);const E=e.useRef(null);const v=e.useRef(null);const I=e.useRef(false);const T=e.useRef(null);const h=n(o.ref,T);const g=e.useRef(null);e.useEffect((()=>{f&&T.current&&(I.current=!c)}),[c,f]);e.useEffect((()=>{if(!f||!T.current)return;const e=r(T.current);if(!T.current.contains(e.activeElement)){if(!T.current.hasAttribute("tabIndex")){process.env.NODE_ENV!=="production"&&console.error(["MUI: The modal content node does not accept focus.",'For the benefit of assistive technologies, the tabIndex of the node is being set to "-1".'].join("\n"));T.current.setAttribute("tabIndex","-1")}I.current&&T.current.focus()}return()=>{if(!i){if(E.current&&E.current.focus){b.current=true;E.current.focus()}E.current=null}}}),[f]);e.useEffect((()=>{if(!f||!T.current)return;const e=r(T.current);const loopFocus=t=>{g.current=t;if(!a&&d()&&t.key==="Tab"&&e.activeElement===T.current&&t.shiftKey){b.current=true;m.current&&m.current.focus()}};const contain=()=>{const t=T.current;if(t===null)return;if(!e.hasFocus()||!d()||b.current){b.current=false;return}if(t.contains(e.activeElement))return;if(a&&e.activeElement!==p.current&&e.activeElement!==m.current)return;if(e.activeElement!==v.current)v.current=null;else if(v.current!==null)return;if(!I.current)return;let n=[];e.activeElement!==p.current&&e.activeElement!==m.current||(n=l(T.current));if(n.length>0){var r,o;const e=Boolean(((r=g.current)==null?void 0:r.shiftKey)&&((o=g.current)==null?void 0:o.key)==="Tab");const t=n[0];const c=n[n.length-1];typeof t!=="string"&&typeof c!=="string"&&(e?c.focus():t.focus())}else t.focus()};e.addEventListener("focusin",contain);e.addEventListener("keydown",loopFocus,true);const t=setInterval((()=>{e.activeElement&&e.activeElement.tagName==="BODY"&&contain()}),50);return()=>{clearInterval(t);e.removeEventListener("focusin",contain);e.removeEventListener("keydown",loopFocus,true)}}),[c,a,i,d,f,l]);const onFocus=e=>{E.current===null&&(E.current=e.relatedTarget);I.current=true;v.current=e.target;const t=o.props.onFocus;t&&t(e)};const handleFocusSentinel=e=>{E.current===null&&(E.current=e.relatedTarget);I.current=true};return s(e.Fragment,{children:[u("div",{tabIndex:f?0:-1,onFocus:handleFocusSentinel,ref:p,"data-testid":"sentinelStart"}),e.cloneElement(o,{ref:h,onFocus:onFocus}),u("div",{tabIndex:f?0:-1,onFocus:handleFocusSentinel,ref:m,"data-testid":"sentinelEnd"})]})}process.env.NODE_ENV!=="production"?FocusTrap.propTypes={children:o,disableAutoFocus:t.bool,disableEnforceFocus:t.bool,disableRestoreFocus:t.bool,
/**
   * Returns an array of ordered tabbable nodes (i.e. in tab order) within the root.
   * For instance, you can provide the "tabbable" npm dependency.
   * @param {HTMLElement} root
   */
getTabbable:t.func,isEnabled:t.func,open:t.bool.isRequired}:void 0;process.env.NODE_ENV!=="production"&&(FocusTrap.propTypes=c(FocusTrap.propTypes));export{FocusTrap};

