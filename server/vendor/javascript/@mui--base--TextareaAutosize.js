import e from"@babel/runtime/helpers/esm/extends";import t from"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose";import*as o from"react";import r from"prop-types";import*as n from"react-dom";import{unstable_useForkRef as s,unstable_ownerWindow as i,unstable_debounce as l,unstable_useEnhancedEffect as a}from"@mui/utils";import{jsx as c,jsxs as u}from"react/jsx-runtime";"use client";const m=["onChange","maxRows","minRows","style","value"];function getStyleValue(e){return parseInt(e,10)||0}const d={shadow:{visibility:"hidden",position:"absolute",overflow:"hidden",height:0,top:0,left:0,transform:"translateZ(0)"}};function isEmpty(e){return e===void 0||e===null||Object.keys(e).length===0||e.outerHeightStyle===0&&!e.overflow}const p=o.forwardRef((function TextareaAutosize(r,p){const{onChange:h,maxRows:f,minRows:y=1,style:g,value:v}=r,b=t(r,m);const{current:w}=o.useRef(v!=null);const x=o.useRef(null);const S=s(p,x);const R=o.useRef(null);const E=o.useRef(0);const[N,O]=o.useState({outerHeightStyle:0});const T=o.useCallback((()=>{const e=x.current;const t=i(e);const o=t.getComputedStyle(e);if(o.width==="0px")return{outerHeightStyle:0};const n=R.current;n.style.width=o.width;n.value=e.value||r.placeholder||"x";n.value.slice(-1)==="\n"&&(n.value+=" ");const s=o.boxSizing;const l=getStyleValue(o.paddingBottom)+getStyleValue(o.paddingTop);const a=getStyleValue(o.borderBottomWidth)+getStyleValue(o.borderTopWidth);const c=n.scrollHeight;n.value="x";const u=n.scrollHeight;let m=c;y&&(m=Math.max(Number(y)*u,m));f&&(m=Math.min(Number(f)*u,m));m=Math.max(m,u);const d=m+(s==="border-box"?l+a:0);const p=Math.abs(m-c)<=1;return{outerHeightStyle:d,overflow:p}}),[f,y,r.placeholder]);const updateState=(e,t)=>{const{outerHeightStyle:o,overflow:r}=t;if(E.current<20&&(o>0&&Math.abs((e.outerHeightStyle||0)-o)>1||e.overflow!==r)){E.current+=1;return{overflow:r,outerHeightStyle:o}}process.env.NODE_ENV!=="production"&&E.current===20&&console.error(["MUI: Too many re-renders. The layout is unstable.","TextareaAutosize limits the number of renders to prevent an infinite loop."].join("\n"));return e};const H=o.useCallback((()=>{const e=T();isEmpty(e)||O((t=>updateState(t,e)))}),[T]);a((()=>{const syncHeightWithFlushSync=()=>{const e=T();isEmpty(e)||n.flushSync((()=>{O((t=>updateState(t,e)))}))};const handleResize=()=>{E.current=0;syncHeightWithFlushSync()};let e;const rAFHandleResize=()=>{cancelAnimationFrame(e);e=requestAnimationFrame((()=>{handleResize()}))};const t=l(handleResize);const o=x.current;const r=i(o);r.addEventListener("resize",t);let s;if(typeof ResizeObserver!=="undefined"){s=new ResizeObserver(process.env.NODE_ENV==="test"?rAFHandleResize:handleResize);s.observe(o)}return()=>{t.clear();cancelAnimationFrame(e);r.removeEventListener("resize",t);s&&s.disconnect()}}),[T]);a((()=>{H()}));o.useEffect((()=>{E.current=0}),[v]);const handleChange=e=>{E.current=0;w||H();h&&h(e)};return u(o.Fragment,{children:[c("textarea",e({value:v,onChange:handleChange,ref:S,rows:y,style:e({height:N.outerHeightStyle,overflow:N.overflow?"hidden":void 0},g)},b)),c("textarea",{"aria-hidden":true,className:r.className,readOnly:true,ref:R,tabIndex:-1,style:e({},d.shadow,g,{paddingTop:0,paddingBottom:0})})]})}));process.env.NODE_ENV!=="production"?p.propTypes={className:r.string,maxRows:r.oneOfType([r.number,r.string]),minRows:r.oneOfType([r.number,r.string]),onChange:r.func,placeholder:r.string,style:r.object,value:r.oneOfType([r.arrayOf(r.string),r.number,r.string])}:void 0;"use client";export{p as TextareaAutosize};

