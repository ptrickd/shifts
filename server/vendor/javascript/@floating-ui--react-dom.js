import{arrow as e,computePosition as t}from"@floating-ui/dom";export{autoPlacement,autoUpdate,computePosition,detectOverflow,flip,getOverflowAncestors,hide,inline,limitShift,offset,platform,shift,size}from"@floating-ui/dom";import*as n from"react";import{useLayoutEffect as r,useEffect as o}from"react";import*as u from"react-dom";const arrow=t=>{function isRef(e){return{}.hasOwnProperty.call(e,"current")}return{name:"arrow",options:t,fn(n){const{element:r,padding:o}=typeof t==="function"?t(n):t;return r&&isRef(r)?r.current!=null?e({element:r.current,padding:o}).fn(n):{}:r?e({element:r,padding:o}).fn(n):{}}}};var s=typeof document!=="undefined"?r:o;function deepEqual(e,t){if(e===t)return true;if(typeof e!==typeof t)return false;if(typeof e==="function"&&e.toString()===t.toString())return true;let n;let r;let o;if(e&&t&&typeof e==="object"){if(Array.isArray(e)){n=e.length;if(n!==t.length)return false;for(r=n;r--!==0;)if(!deepEqual(e[r],t[r]))return false;return true}o=Object.keys(e);n=o.length;if(n!==Object.keys(t).length)return false;for(r=n;r--!==0;)if(!{}.hasOwnProperty.call(t,o[r]))return false;for(r=n;r--!==0;){const n=o[r];if((n!=="_owner"||!e.$$typeof)&&!deepEqual(e[n],t[n]))return false}return true}return e!==e&&t!==t}function getDPR(e){if(typeof window==="undefined")return 1;const t=e.ownerDocument.defaultView||window;return t.devicePixelRatio||1}function roundByDPR(e,t){const n=getDPR(e);return Math.round(t*n)/n}function useLatestRef(e){const t=n.useRef(e);s((()=>{t.current=e}));return t}function useFloating(e){e===void 0&&(e={});const{placement:r="bottom",strategy:o="absolute",middleware:f=[],platform:i,elements:{reference:a,floating:l}={},transform:c=true,whileElementsMounted:d,open:p}=e;const[m,g]=n.useState({x:0,y:0,strategy:o,placement:r,middlewareData:{},isPositioned:false});const[y,w]=n.useState(f);deepEqual(y,f)||w(f);const[R,P]=n.useState(null);const[h,S]=n.useState(null);const b=n.useCallback((e=>{if(e!==M.current){M.current=e;P(e)}}),[]);const x=n.useCallback((e=>{if(e!==O.current){O.current=e;S(e)}}),[]);const D=a||R;const E=l||h;const M=n.useRef(null);const O=n.useRef(null);const k=n.useRef(m);const q=d!=null;const v=useLatestRef(d);const C=useLatestRef(i);const j=n.useCallback((()=>{if(!M.current||!O.current)return;const e={placement:r,strategy:o,middleware:y};C.current&&(e.platform=C.current);t(M.current,O.current,e).then((e=>{const t={...e,isPositioned:true};if(A.current&&!deepEqual(k.current,t)){k.current=t;u.flushSync((()=>{g(t)}))}}))}),[y,r,o,C]);s((()=>{if(p===false&&k.current.isPositioned){k.current.isPositioned=false;g((e=>({...e,isPositioned:false})))}}),[p]);const A=n.useRef(false);s((()=>{A.current=true;return()=>{A.current=false}}),[]);s((()=>{D&&(M.current=D);E&&(O.current=E);if(D&&E){if(v.current)return v.current(D,E,j);j()}}),[D,E,j,v,q]);const B=n.useMemo((()=>({reference:M,floating:O,setReference:b,setFloating:x})),[b,x]);const F=n.useMemo((()=>({reference:D,floating:E})),[D,E]);const L=n.useMemo((()=>{const e={position:o,left:0,top:0};if(!F.floating)return e;const t=roundByDPR(F.floating,m.x);const n=roundByDPR(F.floating,m.y);return c?{...e,transform:"translate("+t+"px, "+n+"px)",...getDPR(F.floating)>=1.5&&{willChange:"transform"}}:{position:o,left:t,top:n}}),[o,c,F.floating,m.x,m.y]);return n.useMemo((()=>({...m,update:j,refs:B,elements:F,floatingStyles:L})),[m,j,B,F,L])}export{arrow,useFloating};

